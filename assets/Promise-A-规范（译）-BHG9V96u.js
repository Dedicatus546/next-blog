import{createElementBlock as i,openBlock as c,createStaticVNode as t}from"vue";const l={class:"kan-doc"},a="Promise A+è§„èŒƒï¼ˆè¯‘ï¼‰",h=1591925197,u="2020-06-12T09:26:37.000Z",p="2023-02-13T18:28:45.000Z",m=["JavaScript"],f=["ç¼–ç¨‹"],b=13292,k={__name:"Promise-A-è§„èŒƒï¼ˆè¯‘ï¼‰",setup(d,{expose:o}){return o({frontmatter:{title:"Promise A+è§„èŒƒï¼ˆè¯‘ï¼‰",key:1591925197,date:"2020-06-12T09:26:37.000Z",updated:"2023-02-13T18:28:45.000Z",tags:["JavaScript"],categories:["ç¼–ç¨‹"],wordCount:13292}}),(s,e)=>(c(),i("div",l,e[0]||(e[0]=[t('<h1 id="å‰è¨€" tabindex="-1">å‰è¨€ <a class="header-anchor" href="#å‰è¨€">ğŸ”—</a></h1><p>è¯•ç€ç¿»è¯‘ä¸‹ECMAä¸­å¯¹Promiseå®ç°è§„èŒƒï¼Œé¡ºä¾¿å­¦ä¹ ä¸‹Promiseï¼ˆæ‰¿è¯ºï¼‰ã€‚</p><h1 id="è¯‘æ–‡" tabindex="-1">è¯‘æ–‡ <a class="header-anchor" href="#è¯‘æ–‡">ğŸ”—</a></h1><blockquote><p>åŸæ–‡åœ°å€ <a href="https://promisesaplus.com" target="_blank" rel="noopener">Promise/A+</a></p></blockquote><p>okï¼Œå¼€å§‹ä¸€æ®µä¸€æ®µçš„ç¿»è¯‘</p><blockquote><p><strong>An open standard for sound, interoperable JavaScript promisesâ€”by implementers, for implementers.</strong></p></blockquote><p>è¯‘ï¼šä¸€ä¸ªå®Œæ•´å¼€æ”¾çš„ï¼Œå¯äº’ç›¸æ“ä½œçš„JavaScript Promiseçš„å¼€æ”¾æ ‡å‡†ï¼Œç”±å®ç°è€…æŒ‡å®šï¼Œé¢å‘å®ç°è€…ã€‚</p><blockquote><p>A <em>promise</em> represents the eventual result of an asynchronous operation. The primary way of interacting with a promise is through its <code>then</code> method, which registers callbacks to receive either a promiseâ€™s eventual value or the reason why the promise cannot be fulfilled.</p></blockquote><p>è¯‘ï¼šä¸€ä¸ªpromiseæ„å‘³ç€ä¸€ä¸ªä¸æ˜¯ç°åœ¨å‘ç”Ÿï¼ˆéå…±æ—¶ï¼‰çš„æ“ä½œçš„æœ€ç»ˆç»“æœã€‚ä¸ä¸€ä¸ªpromiseè¿›è¡Œäº¤æµçš„åŸºæœ¬çš„æ–¹å¼æ˜¯é€šè¿‡å®ƒçš„<code>then</code>æ–¹æ³•ï¼Œ<code>then</code>æ–¹æ³•æ³¨å†Œäº†ä¸€ä¸ªçš„å›è°ƒå‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°è¦ä¹ˆæ¥æ”¶Promiseçš„æœ€ç»ˆå€¼ï¼Œè¦ä¹ˆæ¥æ”¶ä¸ºä»€ä¹ˆè¿™ä¸ªpromiseä¸èƒ½è½¬ä¸ºå®ŒæˆçŠ¶æ€ï¼ˆfulfilledï¼‰çš„åŸå› ã€‚</p><blockquote><p>This specification details the behavior of the <code>then</code> method, providing an interoperable base which all Promises/A+ conformant promise implementations can be depended on to provide. As such, the specification should be considered very stable. Although the Promises/A+ organization may occasionally revise this specification with minor backward-compatible changes to address newly-discovered corner cases, we will integrate large or backward-incompatible changes only after careful consideration, discussion, and testing.</p></blockquote><p>è¯‘ï¼šè§„èŒƒè¯¦ç»†è¯´æ˜äº†<code>then</code>æ–¹æ³•çš„çš„è¡Œä¸ºï¼Œæä¾›äº†ä¸€ä¸ªå¯ä»¥äº’ç›¸æ“ä½œçš„åŸºç¡€æ¥è§„å®šè¡Œä¸ºï¼Œæ‰€æœ‰å’ŒPromise/A+è§„èŒƒä¸€è‡´çš„promiseå®ç°ä¾èµ–è¿™ä¸ªåŸºç¡€ã€‚å› æ­¤ï¼Œè§„èŒƒåº”è¯¥è¢«è®¤ä¸ºæ˜¯éå¸¸ç¨³å®šçš„ã€‚è™½ç„¶Promise/A+ç»„ç»‡å¯èƒ½å¶å°”ä¿®æ”¹è¿™ä»½è§„èŒƒä¸­å°‘æ•°çš„å¯ä»¥å‘åå…¼å®¹çš„å˜åŒ–æ¥è§£å†³æ–°å‘ç°çš„æç«¯æƒ…å†µï¼Œä½†æ˜¯åªæœ‰åœ¨ç»è¿‡æ·±æ€ç†Ÿè™‘ï¼Œè®¨è®ºå’Œæµ‹è¯•åæ‰ä¼šåˆå¹¶å¤§å‹çš„æˆ–è€…ä¸èƒ½å‘åå…¼å®¹çš„å˜åŒ–ã€‚</p><blockquote><p>Historically, Promises/A+ clarifies the behavioral clauses of the earlier <a href="http://wiki.commonjs.org/wiki/Promises/A" target="_blank" rel="noopener">Promises/A proposal</a>, extending it to cover <em>de facto</em> behaviors and omitting parts that are underspecified or problematic.</p></blockquote><p>è¯‘ï¼šå†å²ä¸Šï¼ŒPromise/A+é˜æ˜äº†æ—©æœŸPromise/Aææ¡ˆä¸­çš„è¡Œä¸ºæ¡æ–‡ï¼Œå¹¶æ‰©å±•åˆ°è¦†ç›–å®é™…ä¸Šçš„è¡Œä¸ºå’Œå¿½ç•¥æœªæŒ‡å®šå’Œæœ‰é—®é¢˜çš„éƒ¨åˆ†ã€‚</p><blockquote><p>Finally, the core Promises/A+ specification does not deal with how to create, fulfill, or reject promises, choosing instead to focus on providing an interoperable <code>then</code> method. Future work in companion specifications may touch on these subjects.</p></blockquote><p>è¯‘ï¼šæœ€åï¼Œæ ¸å¿ƒçš„Promise/A+è§„èŒƒæ²¡æœ‰å¤„ç†å¦‚ä½•åˆ›å»ºï¼Œå®Œæˆï¼Œæˆ–è€…æ‹’ç»Promiseï¼Œè€Œæ˜¯ä¸“æ³¨äºæä¾›ä¸€ä¸ªå¯ä»¥äº’ç›¸æ“ä½œçš„<code>then</code>æ–¹æ³•ï¼Œåœ¨æœªæ¥çš„é…å¥—è§„èŒƒä¸­ä¼šæ¶‰åŠè¿™äº›é—®é¢˜ã€‚</p><h2 id="_1-terminologyï¼ˆæœ¯è¯­ï¼‰" tabindex="-1">1. Terminologyï¼ˆæœ¯è¯­ï¼‰ <a class="header-anchor" href="#_1-terminologyï¼ˆæœ¯è¯­ï¼‰">ğŸ”—</a></h2><blockquote><ul><li>&#39;promise&#39; is an object or function with a <code>then</code> method whose behaior conforms to this specification.</li><li>&#39;thenable&#39; is an object or function that defines a <code>then</code> method.</li><li>&#39;value&#39; is any legal JavaScript value (including <code>undefined</code>, a thenable, or a promise).</li><li>&#39;exception&#39; is a value that is thrown using the <code>throw</code> statement.</li><li>&#39;reason&#39; is a value that indicates why a promise was rejected.</li></ul></blockquote><p>è¯‘ï¼š</p><ul><li>â€œpromiseâ€åº”è¯¥æ˜¯ä¸€ä¸ªå¸¦æœ‰<code>then</code>æ–¹æ³•çš„å¯¹è±¡æˆ–è€…å‡½æ•°ï¼Œè¿™ä¸ª<code>then</code>æ–¹æ³•çš„è¡Œä¸ºç¬¦åˆè¿™ä»½è§„èŒƒã€‚</li><li>â€œthenableâ€æ˜¯ä¸€ä¸ªå®šä¹‰äº†<code>then</code>æ–¹æ³•çš„å¯¹è±¡æˆ–è€…å‡½æ•°ã€‚</li><li>â€œvalueâ€å¯ä»¥æ˜¯ä»»ä½•åˆæ³•çš„JavaScriptçš„å€¼ï¼ˆåŒ…æ‹¬<code>undefined</code>ï¼Œä¸€ä¸ªthenableæˆ–è€…ä¸€ä¸ªpromiseï¼‰ã€‚</li><li>â€œexceptionâ€æ˜¯ä¸€ä¸ªä½¿ç”¨äº†å¼‚å¸¸è¯­å¥æ‰€æŠ›å‡ºçš„å€¼ã€‚</li><li>â€œreasonâ€æ˜¯ä¸€ä¸ªè¡¨ç¤ºä¸ºä»€ä¹ˆpromiseè¢«æ‹’ç»çš„å€¼ã€‚</li></ul><h2 id="_2-requirementsï¼ˆè¦æ±‚ï¼‰" tabindex="-1">2. Requirementsï¼ˆè¦æ±‚ï¼‰ <a class="header-anchor" href="#_2-requirementsï¼ˆè¦æ±‚ï¼‰">ğŸ”—</a></h2><h3 id="_2-1-promise-statesï¼ˆpromiseçš„çŠ¶æ€ï¼‰" tabindex="-1">2.1 Promise Statesï¼ˆPromiseçš„çŠ¶æ€ï¼‰ <a class="header-anchor" href="#_2-1-promise-statesï¼ˆpromiseçš„çŠ¶æ€ï¼‰">ğŸ”—</a></h3><blockquote><p>A promise must be in one of three states: pending, fulfilled, or rejected.</p></blockquote><p>è¯‘ï¼šä¸€ä¸ªPromiseçš„çŠ¶æ€å¿…é¡»æ˜¯ç­‰å¾…çŠ¶æ€ï¼Œå®ŒæˆçŠ¶æ€ï¼Œæˆ–è€…æ‹’ç»çŠ¶æ€ä¸­çš„ä¸€ä¸ªã€‚</p><blockquote><ul><li>When pending, a promise: <ul><li>may transition to either the fulfilled or rejected state.</li></ul></li><li>When fulfilled, a promise: <ul><li>must not transition to any other state.</li><li>must have a value, which must not change.</li></ul></li><li>When rejected, a promise: <ul><li>must not transition to any other state.</li><li>must have a reason, which must not change.</li></ul></li></ul></blockquote><p>è¯‘ï¼š</p><ul><li>å½“promiseå¤„äºç­‰å¾…çŠ¶æ€çš„æ—¶å€™ï¼š <ul><li>promiseå¯ä»¥è½¬å˜æˆå®ŒæˆçŠ¶æ€æˆ–è€…æ‹’ç»çŠ¶æ€çš„å…¶ä¸­ä¸€ä¸ªçŠ¶æ€ã€‚</li></ul></li><li>å½“promiseå¤„äºå®ŒæˆçŠ¶æ€çš„æ—¶å€™ï¼š <ul><li>ä¸èƒ½è½¬å˜æˆå…¶ä»–ä»»ä½•çŠ¶æ€ã€‚</li><li>å¿…é¡»æœ‰ä¸€ä¸ªvalueï¼Œå¹¶ä¸”è¿™ä¸ªvalueä¸èƒ½æ”¹å˜ã€‚</li></ul></li><li>å½“promiseå¤„äºæ‹’ç»çŠ¶æ€çš„æ—¶å€™ï¼š <ul><li>ä¸èƒ½è½¬å˜æˆå…¶ä»–ä»»ä½•çŠ¶æ€ã€‚</li><li>å¿…é¡»æœ‰ä¸€ä¸ªreasonï¼Œå¹¶ä¸”è¿™ä¸ªreasonä¸èƒ½æ”¹å˜ã€‚</li></ul></li></ul><blockquote><p>Here, â€œmust not changeâ€ means immutable identity (i.e. <code>===</code>), but does not imply deep immutability.</p></blockquote><p>è¯‘ï¼šè¿™é‡Œçš„â€ä¸èƒ½æ”¹å˜â€çš„æ„æ€æ˜¯ç‰¹å¾ä¸å˜ï¼ˆå³ä¸¥æ ¼ç›¸ç­‰ <code>===</code> ï¼‰ï¼Œä½†ä¸æ˜¯æ„å‘³ç€æ·±å±‚æ¬¡çš„ä¸å˜ã€‚ï¼ˆæ„æ€åº”è¯¥æ˜¯æµ…ç›¸ç­‰ï¼Œä½†ä¸æ˜¯æ·±ç›¸ç­‰ï¼‰</p><h3 id="_2-2-the-then-methodï¼ˆthenæ–¹æ³•ï¼‰" tabindex="-1">2.2 The <code>then</code> Methodï¼ˆ<code>then</code>æ–¹æ³•ï¼‰ <a class="header-anchor" href="#_2-2-the-then-methodï¼ˆthenæ–¹æ³•ï¼‰">ğŸ”—</a></h3><blockquote><p>A promise must provide a <code>then</code> method to access its current or eventual value or reason.</p></blockquote><p>è¯‘ï¼šä¸€ä¸ªpromiseå¿…é¡»æä¾›ä¸€ä¸ª<code>then</code>æ–¹æ³•æ¥ä½¿ç”¨å®ƒå½“å‰æˆ–è€…æœ€ç»ˆçš„å€¼æˆ–è€…ï¼ˆæ‹’ç»çŠ¶æ€çš„ï¼‰åŸå› ã€‚</p><blockquote><p>A promiseâ€™s <code>then</code> method accepts two arguments:</p></blockquote><p>è¯‘ï¼špromiseçš„<code>then</code>æ–¹æ³•æ¥æ”¶ä¸¤ä¸ªå‚æ•°</p><blockquote><p><code>promise.then(onFulfilled, onRejected)</code></p><ul><li>Both <code>onFulfilled</code> and <code>onRejected</code> are optional arguments: <ul><li>If <code>onFulfilled</code> is not a function, it must be ignored.</li><li>If <code>onRejected</code> is not a function, it must be ignored.</li></ul></li></ul></blockquote><p>è¯‘ï¼š</p><ul><li><code>onFulfilled</code>å’Œ<code>onRejected</code>å‚æ•°éƒ½æ˜¯å¯é€‰çš„çš„å‚æ•°: <ul><li>å¦‚æœ<code>onFulfilled</code>ä¸æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œåˆ™å°†è¢«å¿½ç•¥ã€‚</li><li>å¦‚æœ<code>onRejected</code>ä¸æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œåˆ™å°†è¢«å¿½ç•¥ã€‚</li></ul></li></ul><blockquote><ul><li>If <code>onFulfilled</code> is a function: <ul><li>it must be called after <code>promise</code> is fulfilled, with <code>promise</code>â€˜s value as its first argument.</li><li>it must not be called before <code>promise</code> is fulfilled.</li><li>it must not be called more than once.</li></ul></li></ul></blockquote><p>è¯‘ï¼š</p><ul><li>å¦‚æœ<code>onFulfilled</code>æ˜¯ä¸€ä¸ªå‡½æ•°ï¼š <ul><li>åœ¨<code>promise</code>å®Œæˆä¹‹åè°ƒç”¨ï¼Œå¹¶ä¸”å‡½æ•°çš„ç¬¬ä¸€ä¸ªå‚æ•°ä¸º<code>promise</code>çš„<code>value</code>ã€‚</li><li>åœ¨<code>promise</code>å®Œæˆä¹‹å‰ä¸èƒ½è¢«è°ƒç”¨ã€‚</li><li>ä¸èƒ½è¢«è°ƒç”¨è¶…è¿‡ä¸€æ¬¡ã€‚</li></ul></li></ul><blockquote><ul><li>If <code>onRejected</code> is a function: <ul><li>it must be called after <code>promise</code> is rejected, with <code>promise</code>â€™s reason as its first argument.</li><li>it must not be called before <code>promise</code> is rejected.</li><li>it must not be called more than once.</li></ul></li></ul></blockquote><p>è¯‘ï¼š</p><ul><li>å¦‚æœ<code>onRejected</code>æ˜¯ä¸€ä¸ªå‡½æ•° <ul><li>åœ¨<code>promise</code>è¢«æ‹’ç»ä¹‹åè°ƒç”¨ï¼Œå¹¶ä¸”å‡½æ•°çš„ç¬¬ä¸€ä¸ªå‚æ•°ä¸º<code>promise</code>è¢«æ‹’ç»çš„åŸå› ã€‚</li><li>åœ¨<code>promise</code>è¢«æ‹’ç»ä¹‹å‰ä¸èƒ½è¢«è°ƒç”¨ã€‚</li><li>ä¸èƒ½è¢«è°ƒç”¨è¶…è¿‡ä¸€æ¬¡ã€‚</li></ul></li></ul><blockquote><p><code>onFulfilled</code> or <code>onRejected</code> must not be called until the execution context stack contains only platform code.<a href="#3-1">#3.1</a></p></blockquote><p>è¯‘ï¼šåœ¨æ‰§è¡Œä¸Šä¸‹æ–‡çš„å †æ ˆä¸­ä»…åŒ…å«å¹³å°ä»£ç ä¹‹å‰ï¼Œ<code>onFulfilled</code>å’Œ<code>onRejected</code>ä¸èƒ½è¢«è°ƒç”¨ã€‚</p><blockquote><ul><li><code>onFulfilled</code> and <code>onRejected</code> must be called as functions (i.e. with no <code>this</code> value).<a href="#3-2">#3.2</a></li></ul></blockquote><p>è¯‘ï¼š</p><ul><li><code>onFulfilled</code>å’Œ<code>onRejected</code>å‡½æ•°å¿…é¡»ä»¥å‡½æ•°æ–¹å¼è°ƒç”¨ï¼ˆå³ä¸èƒ½æ˜¯<code>this</code>è¿™ä¸ªå€¼ï¼‰ã€‚</li></ul><blockquote><ul><li><code>then</code> may be called multiple times on the same promise. <ul><li>If/when <code>promise</code> is fulfilled, all respective <code>onFulfilled</code> callbacks must execute in the order of their originating calls to <code>then</code>.</li><li>If/when <code>promise</code> is rejected, all respective <code>onRejected</code> callbacks must execute in the order of their originating calls to <code>then</code>.</li></ul></li></ul></blockquote><p>è¯‘ï¼š</p><ul><li>åœ¨åŒä¸€ä¸ª<code>promise</code>ä¸­<code>then</code>æ–¹æ³•å¯ä»¥é‡å¤è°ƒç”¨ã€‚ <ul><li>å¦‚æœæˆ–è€…è¯´å½“<code>promise</code>å®Œæˆæ—¶ï¼Œå„è‡ªçš„<code>onFulfilled</code>å›è°ƒå‡½æ•°å¿…é¡»æŒ‰ç…§å®ƒä»¬æœ€åˆåœ¨<code>then</code>æ–¹æ³•ä¸Šè°ƒç”¨çš„é¡ºåºæ‰§è¡Œã€‚</li><li>å¦‚æœæˆ–è€…è¯´å½“<code>promise</code>è¢«æ‹’ç»æ—¶ï¼Œå„è‡ªçš„<code>onRejected</code>å›è°ƒå‡½æ•°å¿…é¡»æŒ‰ç…§å®ƒä»¬æœ€åˆåœ¨<code>then</code>æ–¹æ³•ä¸Šè°ƒç”¨çš„é¡ºåºæ‰§è¡Œã€‚</li></ul></li></ul><blockquote><ul><li><code>then</code> must return a promise.<a href="#3-3">#3.3</a><br><code>promise2 = promise1.then(onFulfilled, onRejected);</code></li><li>If either <code>onFulfilled</code> or <code>onRejected</code> returns a value <code>x</code>, run the Promise Resolution Procedure <code>[[Resolve]](promise2, x)</code>. <ul><li>If either <code>onFulfilled</code> or <code>onRejected</code> throws an exception <code>e</code>, <code>promise2</code> must be rejected with <code>e</code> as the reason.</li><li>If <code>onFulfilled</code> is not a function and <code>promise1</code> is fulfilled, <code>promise2</code> must be fulfilled with the same value as <code>promise1</code>.</li><li>If <code>onRejected</code> is not a function and <code>promise1</code> is rejected, <code>promise2</code> must be rejected with the same reason as <code>promise1</code>.</li></ul></li></ul></blockquote><p>è¯‘ï¼š</p><ul><li><code>then</code>æ–¹æ³•å¿…é¡»è¿”å›ä¸€ä¸ªpromise <code>promise2 = promise1.then(onFulfilled, onRejected);</code></li><li>å¦‚æœ<code>onFulfilled</code>æˆ–è€…<code>onRejected</code>å…¶ä¸­ä¸€ä¸ªå‡½æ•°è¿”å›äº†ä¸€ä¸ªå€¼<code>x</code>ï¼Œé‚£ä¹ˆæ‰§è¡ŒPromiseçš„è§£å†³è¿‡ç¨‹<code>[[Resolve]](promise2,x)</code><ul><li>å¦‚æœ<code>onFulfilled</code>æˆ–è€…<code>onRejected</code>å…¶ä¸­ä¸€ä¸ªå‡½æ•°æŠ›å‡ºäº†ä¸€ä¸ªå¼‚å¸¸<code>e</code>ï¼Œé‚£ä¹ˆpromise2å¿…é¡»ä¸ºä»¥<code>e</code>ä¸ºåŸå› çš„æ‹’ç»çŠ¶æ€ã€‚</li><li>å¦‚æœ<code>onFulfilled</code>ä¸æ˜¯ä¸€ä¸ªå‡½æ•°è€Œä¸”promise1ä¸ºå®Œæˆæ€æ—¶ï¼Œpromise2å¿…é¡»ä¸ºå®Œæˆæ€å¹¶ä¸”å¸¦æœ‰å’Œpromise1ç›¸åŒçš„å€¼</li><li>å¦‚æœ<code>onRejected</code>ä¸æ˜¯ä¸€ä¸ªå‡½æ•°è€Œä¸”promise1ä¸ºæ‹’ç»æ€æ—¶ï¼Œpromise2å¿…é¡»ä¸ºæ‹’ç»æ€å¹¶ä¸”å¸¦æœ‰å’Œpromise1ç›¸åŒçš„åŸå› ã€‚</li></ul></li></ul><h3 id="_2-3-the-promise-resolution-procedureï¼ˆpromiseçš„è§£å†³ç¨‹åºï¼‰" tabindex="-1">2.3 The Promise Resolution Procedureï¼ˆPromiseçš„è§£å†³ç¨‹åºï¼‰ <a class="header-anchor" href="#_2-3-the-promise-resolution-procedureï¼ˆpromiseçš„è§£å†³ç¨‹åºï¼‰">ğŸ”—</a></h3><blockquote><p>The <strong>promise resolution procedure</strong> is an abstract operation taking as input a promise and a value, which we denote as <code>[[Resolve]](promise, x)</code>. If <code>x</code> is a thenable, it attempts to make <code>promise</code> adopt the state of <code>x</code>, under the assumption that <code>x</code> behaves at least somewhat like a promise. Otherwise, it fulfills <code>promise</code> with the value <code>x</code>.</p></blockquote><p>è¯‘ï¼špromiseè§£å†³è¿‡ç¨‹æ˜¯ä¸€ä¸ªè¾“å…¥ä¸€ä¸ªpromiseæˆ–è€…ä¸€ä¸ªå€¼æŠ½è±¡çš„æ“ä½œï¼Œè¿™ä¸ªæ“ä½œæˆ‘ä»¬ç”¨<code>[[Resolve]](promise, x)</code>è¿™ä¸ªæ ‡è®°æ¥è¡¨ç¤ºã€‚å¦‚æœ<code>x</code>æ˜¯ä¸€ä¸ªthenableå¯¹è±¡çš„è¯ï¼Œåœ¨<code>x</code>çš„è¡Œä¸ºè‡³å°‘æœ‰ç‚¹åƒä¸€ä¸ªpromiseçš„å‡è®¾ä¸‹ï¼Œè¿™ä¸ªæ–¹æ³•å°è¯•å°†<code>promise</code>é‡‡ç”¨<code>x</code>çš„çŠ¶æ€ï¼Œå¦åˆ™ï¼Œè¿™ä¸ªæ–¹æ³•å°†ä»¥<code>x</code>çš„å€¼æ¥å®Œæˆ<code>promise</code>ã€‚</p><blockquote><p>This treatment of thenables allows promise implementations to interoperate, as long as they expose a Promises/AÂ±compliant <code>then</code> method. It also allows Promises/A+ implementations to â€œassimilateâ€ nonconformant implementations with reasonable <code>then</code> methods.</p></blockquote><p>è¯‘ï¼šå¯¹äºthenablesçš„è®ºè¿°å…è®¸promiseçš„å®ç°å¯ä»¥ç›¸äº’æ“ä½œï¼Œåªè¦å®ƒä»¬æš´éœ²äº†ä¸€ä¸ªPromise/A+ä¸€è‡´æ€§çš„<code>then</code>æ–¹æ³•ã€‚å®ƒä¹Ÿå…è®¸Promise/A+å®ç°ä»¥åˆç†çš„<code>then</code>æ–¹æ³•æ¥â€åŒåŒ–â€ä¸ä¸€è‡´çš„å®ç°ã€‚</p><blockquote><p>To run <code>[[Resolve]](promise, x)</code>, perform the following steps:</p></blockquote><p>è¯‘ï¼šä¸ºäº†æ‰§è¡Œ<code>[[Resolve]](promise, x)</code>ï¼Œéœ€è¦å±¥è¡Œä»¥ä¸‹æ­¥éª¤ï¼š</p><blockquote><ul><li>If <code>promise</code> and <code>x</code> refer to the same object, reject <code>promise</code> with a <code>TypeError</code> as the reason.</li></ul></blockquote><p>è¯‘ï¼š</p><ul><li>å¦‚æœ<code>promise</code>å’Œ<code>x</code>æ˜¯åŒä¸€ä¸ªå¯¹è±¡çš„è¯ï¼Œä»¥<code>TypeError</code>ä¸ºåŸå› æ‹’ç»è¿™ä¸ªpromiseã€‚</li></ul><blockquote><ul><li>If <code>x</code> is a promise, adopt its state<a href="#3-4">#3.4</a>: <ul><li>If <code>x</code> is pending, <code>promise</code> must remain pending until <code>x</code> is fulfilled or rejected.</li><li>If/when <code>x</code> is fulfilled, fulfill <code>promise</code> with the same value.</li><li>If/when <code>x</code> is rejected, reject <code>promise</code> with the same reason.</li></ul></li></ul></blockquote><p>è¯‘ï¼š</p><ul><li>å¦‚æœ<code>x</code>æ˜¯ä¸€ä¸ªpromiseï¼Œé‡‡ç”¨å®ƒçš„çŠ¶æ€ï¼š <ul><li>å¦‚æœ<code>x</code>å³å°†å‘ç”Ÿï¼Œ<code>promise</code>å¿…é¡»ä¿æŒå³å°†å‘ç”Ÿçš„çŠ¶æ€ç›´åˆ°xå®Œæˆæˆ–è€…è¢«æ‹’ç»ã€‚</li><li>å¦‚æœæˆ–è€…å½“<code>x</code>å®Œæˆï¼Œä½¿å¾—è¿™ä¸ª<code>promise</code>ä»¥ç›¸åŒçš„å€¼å®Œæˆ</li><li>å¦‚æœæˆ–è€…å½“<code>x</code>è¢«æ‹’ç»ï¼Œä½¿å¾—è¿™ä¸ª<code>promise</code>ä»¥ç›¸åŒçš„åŸå› è¢«æ‹’ç»ã€‚</li></ul></li></ul><blockquote><ul><li>Otherwise, if <code>x</code> is an object or function, <ul><li>Let <code>then</code> be <code>x.then</code>.<a href="#3-5">#3.5</a></li><li>If retrieving the property <code>x.then</code> results in a thrown exception <code>e</code>, reject <code>promise</code> with <code>e</code> as the reason.</li><li>If <code>then</code> is a function, call it with <code>x</code> as <code>this</code>, first argument <code>resolvePromise</code>, and second argument <code>rejectPromise</code>, where: <ul><li>If/when <code>resolvePromise</code> is called with a value <code>y</code>, run [[Resolve]](promise, y).</li><li>If/when <code>rejectPromise</code> is called with a reason <code>r</code>, reject <code>promise</code> with <code>r</code>.</li><li>If both <code>resolvePromise</code> and <code>rejectPromise</code> are called, or multiple calls to the same argument are made, the first call takes precedence, and any further calls are ignored.</li><li>If calling <code>then</code> throws an exception <code>e</code>, <ul><li>If <code>resolvePromise</code> or <code>rejectPromise</code> have been called, ignore it.</li><li>Otherwise, reject <code>promise</code> with <code>e</code> as the reason.</li></ul></li></ul></li><li>If <code>then</code> is not a function, fulfill <code>promise</code> with <code>x</code>.</li></ul></li></ul></blockquote><p>è¯‘ï¼š</p><ul><li>å¦åˆ™ï¼Œå¦‚æœ<code>x</code>æ˜¯ä¸€ä¸ªå¯¹è±¡æˆ–è€…å‡½æ•°ï¼Œ <ul><li>è®¾ç½®<code>then</code>æ–¹æ³•ä¸º<code>x.then</code></li><li>å¦‚æœæ£€ç´¢<code>x.then</code>çš„å±æ€§å¯¼è‡´ä¸€ä¸ªæŠ›å‡ºçš„å¼‚å¸¸<code>e</code>çš„è¯ï¼Œä»¥å¼‚å¸¸<code>e</code>ä¸ºåŸå› æ‹’ç»<code>promise</code>ã€‚</li><li>å¦‚æœ<code>then</code>æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œä»¥<code>x</code>ä¸º<code>this</code>(ä¸Šä¸‹æ–‡)çš„æ–¹å¼è°ƒç”¨ï¼Œç¬¬ä¸€ä¸ªå‚æ•°ä¸º<code>resolvePromise</code>ï¼Œç¬¬äºŒä¸ªå‚æ•°ä¸º<code>rejectPromise</code>ï¼š <ul><li>å¦‚æœæˆ–è€…å½“<code>resolvePromise</code>ä»¥ä¸€ä¸ªå€¼<code>y</code>è¢«è°ƒç”¨ï¼Œæ‰§è¡Œ<code>[[Resolve]](promise,y)</code>ã€‚</li><li>å¦‚æœæˆ–è€…å½“<code>rejectPromise</code>ä»¥ä¸€ä¸ªåŸå› <code>r</code>è¢«è°ƒç”¨ï¼Œä»¥<code>r</code>æ¥æ‹’ç»è¿™ä¸ªpromiseã€‚</li><li>å¦‚æœ<code>resolvePromise</code>å’Œ<code>rejectPromise</code>éƒ½è¢«è°ƒç”¨ï¼Œæˆ–è€…å¯¹åŒä¸€ä¸ªå‚æ•°è¿›è¡Œäº†å¤šæ¬¡çš„è°ƒç”¨ï¼Œåªæœ‰ç¬¬ä¸€æ¬¡è°ƒç”¨ç”Ÿæ•ˆï¼Œå…¶ä»–å³å°†çš„è°ƒç”¨è¢«å¿½ç•¥ã€‚</li><li>å¦‚æœæ‰§è¡Œ<code>then</code>æŠ›å‡ºäº†ä¸€ä¸ªå¼‚å¸¸<code>e</code><ul><li>å¦‚æœ<code>resolvePromise</code>æˆ–è€…<code>rejectPromise</code>å·²ç»è¢«è°ƒç”¨ï¼Œåˆ™å¿½ç•¥å®ƒã€‚</li><li>å¦åˆ™ï¼Œä»¥<code>e</code>ä½œä¸ºåŸå› æ‹’ç»è¿™ä¸ª<code>promise</code>ã€‚</li></ul></li></ul></li><li>å¦‚æœ<code>then</code>ä¸æ˜¯ä¸€ä¸ªå‡½æ•°ï¼Œåˆ™ä»¥<code>x</code>ä¸ºå€¼å®Œæˆ<code>promise</code>ã€‚</li></ul></li></ul><blockquote><ul><li>If <code>x</code> is not an object or function, fulfill <code>promise</code> with <code>x</code>.</li></ul></blockquote><p>è¯‘ï¼š</p><ul><li>å¦‚æœxä¸æ˜¯ä¸€ä¸ªå¯¹è±¡æˆ–è€…å‡½æ•°ï¼Œä»¥<code>x</code>ä¸ºå€¼å®Œæˆpromiseã€‚</li></ul><blockquote><p>If a promise is resolved with a thenable that participates in a circular thenable chain, such that the recursive nature of <code>[[Resolve]](promise, thenable)</code> eventually causes <code>[[Resolve]](promise, thenable)</code> to be called again, following the above algorithm will lead to infinite recursion. Implementations are encouraged, but not required, to detect such recursion and reject <code>promise</code> with an informative <code>TypeError</code> as the reason.<a href="#3-6">#3.6</a></p></blockquote><p>è¯‘ï¼šå¦‚æœä¸€ä¸ªpromiseé€šè¿‡ä¸€ä¸ªthenableè§£å†³ï¼Œè€Œè¿™ä¸ªthenableå‚ä¸äº†ä¸€ä¸ªç¯å½¢çš„thenableé“¾ï¼Œä»¥è‡³äº<code>[[Resolve]](promise, thenable)</code>çš„é€’å½’æ€§è´¨æœ€ç»ˆé€ æˆ<code>[[Resolve]](promise, thenable)</code>è¢«å†ä¸€æ¬¡çš„è°ƒç”¨ï¼Œä»¥ä¸Šçš„è®¡ç®—å°†ä¼šå¯¼è‡´æ— é™çš„é€’å½’ã€‚å®ç°åº”è¯¥é¼“åŠ±å»å‘ç°è¿™æ ·çš„é€’å½’ç„¶åæä¾›ä¸€ä¸ª<code>TypeError</code>é”™è¯¯ä½œä¸ºåŸå› æ¥æ‹’ç»promiseï¼Œä½†è¿™å¹¶ä¸æ˜¯è§„å®šçš„ã€‚</p><h2 id="_3-notesï¼ˆä¸€äº›åœ°æ–¹çš„è§£é‡Šï¼‰" tabindex="-1">3.Notesï¼ˆä¸€äº›åœ°æ–¹çš„è§£é‡Šï¼‰ <a class="header-anchor" href="#_3-notesï¼ˆä¸€äº›åœ°æ–¹çš„è§£é‡Šï¼‰">ğŸ”—</a></h2><h3 id="_3-1" tabindex="-1">3.1 <a class="header-anchor" href="#_3-1">ğŸ”—</a></h3><blockquote><p>Here â€œplatform codeâ€ means engine, environment, and promise implementation code. In practice, this requirement ensures that <code>onFulfilled</code> and <code>onRejected</code> execute asynchronously, after the event loop turn in which <code>then</code> is called, and with a fresh stack. This can be implemented with either a â€œmacro-taskâ€ mechanism such as <code>setTimeout</code> or <code>setImmediate</code>, or with a â€œmicro-taskâ€ mechanism such as <code>MutationObserver</code> or <code>process.nextTick</code>. Since the promise implementation is considered platform code, it may itself contain a task-scheduling queue or â€œtrampolineâ€ in which the handlers are called.</p></blockquote><p>è¯‘ï¼šè¿™é‡Œçš„â€å¹³å°ä»£ç â€æ„æ€æ˜¯æŒ‡å¼•æ“ï¼Œç¯å¢ƒå’Œpromiseå®ç°çš„ä»£ç ã€‚å®é™…ä¸Šï¼Œè¿™ä¸ªè¦æ±‚ç¡®ä¿<code>onFulfilled</code>å’Œ<code>onRejected</code>å‡½æ•°åœ¨<code>then</code>æ–¹æ³•è°ƒç”¨çš„äº‹ä»¶å¾ªç¯ä¹‹åä»¥ä¸€ä¸ªæ–°çš„å †æ ˆå¼‚æ­¥æ‰§è¡Œã€‚å¯ä»¥ä»¥å®ä»»åŠ¡æœºåˆ¶æ¯”å¦‚<code>setTimeout</code>æˆ–è€…<code>setImmediate</code>æ¥å®ç°ï¼Œåˆæˆ–è€…ä»¥å¾®ä»»åŠ¡æœºåˆ¶æ¯”å¦‚<code>MutationObserver</code>æˆ–è€…<code>process.nextTick</code>æ¥å®ç°ã€‚ç”±äºpromiseå®ç°è¢«è®¤ä¸ºæ˜¯å¹³å°ä»£ç ï¼Œå®ƒè‡ªèº«å¯èƒ½åŒ…å«ä¸€ä¸ªè°ƒç”¨å¤„ç†ç¨‹åºçš„ä»»åŠ¡è°ƒåº¦é˜Ÿåˆ—æˆ–è€…â€è¹¦åºŠâ€ã€‚</p><h3 id="_3-2" tabindex="-1">3.2 <a class="header-anchor" href="#_3-2">ğŸ”—</a></h3><blockquote><p>That is, in strict mode <code>this</code> will be <code>undefined</code> inside of them; in sloppy mode, it will be the global object.</p></blockquote><p>è¯‘ï¼šåœ¨ä¸¥æ ¼æ¨¡å¼ä¸‹<code>this</code>åœ¨å†…éƒ¨å°†ä¼šæ˜¯<code>undefined</code>ï¼Œè€Œåœ¨éä¸¥æ ¼æ¨¡å¼ä¸‹ï¼Œå®ƒå°†ä¼šæ˜¯å…¨å±€å¯¹è±¡ã€‚</p><h3 id="_3-3" tabindex="-1">3.3 <a class="header-anchor" href="#_3-3">ğŸ”—</a></h3><blockquote><p>Implementations may allow <code>promise2 === promise1</code>, provided the implementation meets all requirements. Each implementation should document whether it can produce promise2 === promise1 and under what conditions.</p></blockquote><p>è¯‘ï¼šå‡è®¾å®ç°æ»¡è¶³æ‰€æœ‰è¦æ±‚ï¼Œå®ç°å¯èƒ½å…è®¸<code>promise2 === promise1</code>ã€‚æ¯ä¸ªå®ç°åº”è¯¥è®°å½•åœ¨ä»€ä¹ˆæƒ…å†µä¸‹æ˜¯å¦äº§ç”Ÿ<code>promise2 === promise1</code>ã€‚</p><h3 id="_3-4" tabindex="-1">3.4 <a class="header-anchor" href="#_3-4">ğŸ”—</a></h3><blockquote><p>Generally, it will only be known that <code>x</code> is a true promise if it comes from the current implementation. This clause allows the use of implementation-specific means to adopt the state of known-conformant promises.</p></blockquote><p>è¯‘ï¼šä¸€èˆ¬åœ°ï¼Œåªæœ‰åœ¨promiseæ¥è‡ªå½“å‰ï¼ˆè‡ªèº«ï¼‰çš„å®ç°çš„æƒ…å†µæ‰èƒ½çŸ¥é“<code>x</code>æ˜¯ä¸€ä¸ªçœŸçš„promiseã€‚è¿™ä¸ªæ¡æ–‡å…è®¸å…·ä½“å®ç°çš„æ–¹å¼å»é‡‡ç”¨å·²çŸ¥ä¸€è‡´çš„promiseã€‚</p><h3 id="_3-5" tabindex="-1">3.5 <a class="header-anchor" href="#_3-5">ğŸ”—</a></h3><blockquote><p>This procedure of first storing a reference to x.then, then testing that reference, and then calling that reference, avoids multiple accesses to the x.then property. Such precautions are important for ensuring consistency in the face of an accessor property, whose value could change between retrievals.</p></blockquote><p>è¯‘ï¼šç¨‹åºçš„ç¬¬ä¸€æ­¥å‚¨å­˜<code>x.then</code>çš„å¼•ç”¨ï¼Œç„¶åæ£€éªŒå¼•ç”¨ï¼Œç„¶åè°ƒç”¨å¼•ç”¨ï¼Œé¿å…å¤šæ¬¡è·å–<code>x.then</code>çš„å±æ€§ã€‚è¿™æ ·çš„é¢„é˜²å¯¹äºç¡®ä¿é‚£äº›å¯èƒ½åœ¨æ£€ç´¢è¿‡ç¨‹ä¸­å˜åŒ–çš„å­˜å‚¨å±æ€§çš„ä¸€è‡´æ€§å¾ˆé‡è¦ã€‚</p><h3 id="_3-6" tabindex="-1">3.6 <a class="header-anchor" href="#_3-6">ğŸ”—</a></h3><blockquote><p>Implementations should not set arbitrary limits on the depth of thenable chains, and assume that beyond that arbitrary limit the recursion will be infinite. Only true cycles should lead to a <code>TypeError</code>; if an infinite chain of distinct thenables is encountered, recursing forever is the correct behavior.</p></blockquote><p>è¯‘ï¼šå®ç°ä¸åº”è¯¥å¯¹thenableé“¾çš„æ·±åº¦è®¾ç½®ä»»æ„çš„é™åˆ¶ï¼Œå¹¶å‡è®¾è¶…è¿‡è¿™ä¸ªä»»æ„çš„é™åˆ¶é€’å½’å°†æ˜¯æ— é™çš„ã€‚åªæœ‰æ­£ç¡®çš„å¾ªç¯åº”è¯¥å¯¼è‡´ä¸€ä¸ª<code>TypeError</code>çš„é”™è¯¯ï¼›å¦‚æœé‡åˆ°ä¸€ä¸ªä¸åŒçš„thenablesç»„æˆçš„æ— é™çš„é“¾ï¼Œæ°¸ä¹…çš„é€’å½’æ‰æ˜¯æ­£ç¡®çš„è¡Œä¸ºã€‚</p>',93)])))}};export{f as categories,u as date,k as default,h as key,m as tags,a as title,p as updated,b as wordCount};
