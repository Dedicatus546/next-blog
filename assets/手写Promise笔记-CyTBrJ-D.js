import{createElementBlock as n,openBlock as e,createStaticVNode as t}from"vue";import{c as l}from"./app-4gPi1Ho2.js";import"nprogress";import"pinia-plugin-persistedstate";import"vue-router";import"vue-router-better-scroller";import"@vueuse/core";import"@vueuse/components";import"@vueuse/router";import"octokit";import"pinia";import"date-fns";const p={class:"kan-doc"},P="手写Promise笔记",C=1591929291,b="2020-06-12T10:34:51.000Z",x="2023-02-13T18:28:45.000Z",R=["JavaScript","Promise"],_=["编程"],E=1835,w=[{property:"og:title",content:"手写Promise笔记"},{name:"twitter:title",content:"手写Promise笔记"}],T={__name:"手写Promise笔记",setup(i,{expose:a}){return a({frontmatter:{title:"手写Promise笔记",key:1591929291,date:"2020-06-12T10:34:51.000Z",updated:"2023-02-13T18:28:45.000Z",tags:["JavaScript","Promise"],categories:["编程"],wordCount:1835,meta:[{property:"og:title",content:"手写Promise笔记"},{name:"twitter:title",content:"手写Promise笔记"}]}}),l({title:"手写Promise笔记",meta:[{property:"og:title",content:"手写Promise笔记"},{name:"twitter:title",content:"手写Promise笔记"}]}),(o,s)=>(e(),n("div",p,s[0]||(s[0]=[t(`<p>手写<code>Promise</code>笔记</p><p>掘金上看见一个<code>20</code>行的<code>Promise</code>实现，主要是链式调用，感觉很不错，学习学习。</p><p>原文出处：<a href="https://juejin.im/post/5e6f4579f265da576429a907" target="_blank" rel="noopener">最简实现Promise，支持异步链式调用（20行）</a></p><h1 id="promise" tabindex="-1"><code>Promise</code> <a class="header-anchor" href="#promise">🔗</a></h1><p>直接上代码吧。</p><pre class="shiki shiki-themes vitesse-dark vitesse-light" style="--s-dark:#dbd7caee;--s-light:#393a34;--s-dark-bg:#121212;--s-light-bg:#ffffff;" tabindex="0"><code class="language-javascript"><span class="line"><span style="--s-dark:#758575DD;--s-light:#A0ADA0;">// Promise构造函数</span></span>
<span class="line"><span style="--s-dark:#CB7676;--s-light:#AB5959;">function</span><span style="--s-dark:#80A665;--s-light:#59873A;"> Promise</span><span style="--s-dark:#666666;--s-light:#999999;">(</span><span style="--s-dark:#BD976A;--s-light:#B07D48;">excutor</span><span style="--s-dark:#666666;--s-light:#999999;">)</span><span style="--s-dark:#666666;--s-light:#999999;"> {</span></span>
<span class="line"><span style="--s-dark:#CB7676;--s-light:#AB5959;">  var</span><span style="--s-dark:#BD976A;--s-light:#B07D48;"> self</span><span style="--s-dark:#666666;--s-light:#999999;"> =</span><span style="--s-dark:#C99076;--s-light:#A65E2B;"> this</span><span style="--s-dark:#666666;--s-light:#999999;">;</span></span>
<span class="line"><span style="--s-dark:#BD976A;--s-light:#B07D48;">  self</span><span style="--s-dark:#666666;--s-light:#999999;">.</span><span style="--s-dark:#BD976A;--s-light:#B07D48;">onResolvedCallback</span><span style="--s-dark:#666666;--s-light:#999999;"> =</span><span style="--s-dark:#666666;--s-light:#999999;"> [];</span></span>
<span class="line"><span style="--s-dark:#CB7676;--s-light:#AB5959;">  function</span><span style="--s-dark:#80A665;--s-light:#59873A;"> resolve</span><span style="--s-dark:#666666;--s-light:#999999;">(</span><span style="--s-dark:#BD976A;--s-light:#B07D48;">value</span><span style="--s-dark:#666666;--s-light:#999999;">)</span><span style="--s-dark:#666666;--s-light:#999999;"> {</span></span>
<span class="line"><span style="--s-dark:#80A665;--s-light:#59873A;">    setTimeout</span><span style="--s-dark:#666666;--s-light:#999999;">(()</span><span style="--s-dark:#666666;--s-light:#999999;"> =&gt;</span><span style="--s-dark:#666666;--s-light:#999999;"> {</span></span>
<span class="line"><span style="--s-dark:#BD976A;--s-light:#B07D48;">      self</span><span style="--s-dark:#666666;--s-light:#999999;">.</span><span style="--s-dark:#BD976A;--s-light:#B07D48;">data</span><span style="--s-dark:#666666;--s-light:#999999;"> =</span><span style="--s-dark:#BD976A;--s-light:#B07D48;"> value</span><span style="--s-dark:#666666;--s-light:#999999;">;</span></span>
<span class="line"><span style="--s-dark:#BD976A;--s-light:#B07D48;">      self</span><span style="--s-dark:#666666;--s-light:#999999;">.</span><span style="--s-dark:#BD976A;--s-light:#B07D48;">onResolvedCallback</span><span style="--s-dark:#666666;--s-light:#999999;">.</span><span style="--s-dark:#80A665;--s-light:#59873A;">forEach</span><span style="--s-dark:#666666;--s-light:#999999;">(</span><span style="--s-dark:#BD976A;--s-light:#B07D48;">callback</span><span style="--s-dark:#666666;--s-light:#999999;"> =&gt;</span><span style="--s-dark:#80A665;--s-light:#59873A;"> callback</span><span style="--s-dark:#666666;--s-light:#999999;">(</span><span style="--s-dark:#BD976A;--s-light:#B07D48;">value</span><span style="--s-dark:#666666;--s-light:#999999;">));</span></span>
<span class="line"><span style="--s-dark:#666666;--s-light:#999999;">    },</span><span style="--s-dark:#4C9A91;--s-light:#2F798A;">0</span><span style="--s-dark:#666666;--s-light:#999999;">);</span></span>
<span class="line"><span style="--s-dark:#666666;--s-light:#999999;">  }</span></span>
<span class="line"><span style="--s-dark:#80A665;--s-light:#59873A;">  excutor</span><span style="--s-dark:#666666;--s-light:#999999;">(</span><span style="--s-dark:#BD976A;--s-light:#B07D48;">resolve</span><span style="--s-dark:#666666;--s-light:#999999;">.</span><span style="--s-dark:#80A665;--s-light:#59873A;">bind</span><span style="--s-dark:#666666;--s-light:#999999;">(</span><span style="--s-dark:#BD976A;--s-light:#B07D48;">self</span><span style="--s-dark:#666666;--s-light:#999999;">));</span></span>
<span class="line"><span style="--s-dark:#666666;--s-light:#999999;">}</span></span>
<span class="line"><span style="--s-dark:#758575DD;--s-light:#A0ADA0;">// Promise的then调用函数</span></span>
<span class="line"><span style="--s-dark:#B8A965;--s-light:#998418;">Promise</span><span style="--s-dark:#666666;--s-light:#999999;">.</span><span style="--s-dark:#B8A965;--s-light:#998418;">prototype</span><span style="--s-dark:#666666;--s-light:#999999;">.</span><span style="--s-dark:#80A665;--s-light:#59873A;">then</span><span style="--s-dark:#666666;--s-light:#999999;"> =</span><span style="--s-dark:#CB7676;--s-light:#AB5959;"> function</span><span style="--s-dark:#666666;--s-light:#999999;">(</span><span style="--s-dark:#BD976A;--s-light:#B07D48;">onResolved</span><span style="--s-dark:#666666;--s-light:#999999;">)</span><span style="--s-dark:#666666;--s-light:#999999;"> {</span></span>
<span class="line"><span style="--s-dark:#CB7676;--s-light:#AB5959;">  var</span><span style="--s-dark:#BD976A;--s-light:#B07D48;"> self</span><span style="--s-dark:#666666;--s-light:#999999;"> =</span><span style="--s-dark:#C99076;--s-light:#A65E2B;"> this</span><span style="--s-dark:#666666;--s-light:#999999;">;</span></span>
<span class="line"><span style="--s-dark:#4D9375;--s-light:#1E754F;">  return</span><span style="--s-dark:#CB7676;--s-light:#AB5959;"> new</span><span style="--s-dark:#B8A965;--s-light:#998418;"> Promise</span><span style="--s-dark:#666666;--s-light:#999999;">(</span><span style="--s-dark:#BD976A;--s-light:#B07D48;">resolve</span><span style="--s-dark:#666666;--s-light:#999999;"> =&gt;</span><span style="--s-dark:#666666;--s-light:#999999;"> {</span></span>
<span class="line"><span style="--s-dark:#BD976A;--s-light:#B07D48;">    self</span><span style="--s-dark:#666666;--s-light:#999999;">.</span><span style="--s-dark:#BD976A;--s-light:#B07D48;">onResolvedCallback</span><span style="--s-dark:#666666;--s-light:#999999;">.</span><span style="--s-dark:#80A665;--s-light:#59873A;">push</span><span style="--s-dark:#666666;--s-light:#999999;">(</span><span style="--s-dark:#CB7676;--s-light:#AB5959;">function</span><span style="--s-dark:#666666;--s-light:#999999;">()</span><span style="--s-dark:#666666;--s-light:#999999;"> {</span></span>
<span class="line"><span style="--s-dark:#CB7676;--s-light:#AB5959;">      var</span><span style="--s-dark:#BD976A;--s-light:#B07D48;"> result</span><span style="--s-dark:#666666;--s-light:#999999;"> =</span><span style="--s-dark:#80A665;--s-light:#59873A;"> onResolved</span><span style="--s-dark:#666666;--s-light:#999999;">(</span><span style="--s-dark:#BD976A;--s-light:#B07D48;">self</span><span style="--s-dark:#666666;--s-light:#999999;">.</span><span style="--s-dark:#BD976A;--s-light:#B07D48;">data</span><span style="--s-dark:#666666;--s-light:#999999;">);</span></span>
<span class="line"><span style="--s-dark:#4D9375;--s-light:#1E754F;">      if</span><span style="--s-dark:#666666;--s-light:#999999;"> (</span><span style="--s-dark:#BD976A;--s-light:#B07D48;">result</span><span style="--s-dark:#CB7676;--s-light:#AB5959;"> instanceof</span><span style="--s-dark:#5DA994;--s-light:#2E8F82;"> Promise</span><span style="--s-dark:#666666;--s-light:#999999;">)</span><span style="--s-dark:#666666;--s-light:#999999;"> {</span></span>
<span class="line"><span style="--s-dark:#BD976A;--s-light:#B07D48;">        result</span><span style="--s-dark:#666666;--s-light:#999999;">.</span><span style="--s-dark:#80A665;--s-light:#59873A;">then</span><span style="--s-dark:#666666;--s-light:#999999;">(</span><span style="--s-dark:#BD976A;--s-light:#B07D48;">resolve</span><span style="--s-dark:#666666;--s-light:#999999;">);</span></span>
<span class="line"><span style="--s-dark:#666666;--s-light:#999999;">      }</span><span style="--s-dark:#4D9375;--s-light:#1E754F;"> else</span><span style="--s-dark:#666666;--s-light:#999999;"> {</span></span>
<span class="line"><span style="--s-dark:#80A665;--s-light:#59873A;">        resolve</span><span style="--s-dark:#666666;--s-light:#999999;">(</span><span style="--s-dark:#BD976A;--s-light:#B07D48;">result</span><span style="--s-dark:#666666;--s-light:#999999;">);</span></span>
<span class="line"><span style="--s-dark:#666666;--s-light:#999999;">      }</span></span>
<span class="line"><span style="--s-dark:#666666;--s-light:#999999;">    });</span></span>
<span class="line"><span style="--s-dark:#666666;--s-light:#999999;">  })</span></span>
<span class="line"><span style="--s-dark:#666666;--s-light:#999999;">}</span></span></code></pre><p>参数<code>excutor</code>为一个函数，这个函数有两个参数。</p><p>一个是<code>resolve</code>，一个是<code>reject</code>，这个实现为简单实现，所以没有第二个参数，主要为实现链式调用。</p><p><code>Promise</code>构造函数中的<code>onResolvedCallback</code>为一个待调用的函数数组。</p><p>当通过<code>then</code>函数注册回调的时候，会把回调函数存在<code>onResolvedCallback</code>数组中。</p><p><code>then</code>函数规范中有提到，必须返回一个新的<code>Promise</code>对象，基于这个可以实现链式调用。</p><p><code>then</code>如何返回也在规范中有提及，如果回调函数返回了一个<code>Promise</code>，那么<code>then</code>返回的<code>Promise</code>就要使用函数返回的<code>Promise</code>的值（<code>value</code>）。</p><p>如果不是函数返回的不是<code>Promise</code>，那么<code>then</code>返回的<code>Promise</code>就直接以这个值来解决。</p><p><code>resolve</code>函数是一个完成函数，会把<code>Promise</code>的状态从<code>pending</code>转为<code>resolved</code>，并且调用全部注册的回调。</p><p><code>resolve</code>为啥要通过<code>setTimeout</code>调用呢？可以看下面的代码。</p><pre class="shiki shiki-themes vitesse-dark vitesse-light" style="--s-dark:#dbd7caee;--s-light:#393a34;--s-dark-bg:#121212;--s-light-bg:#ffffff;" tabindex="0"><code class="language-javascript"><span class="line"><span style="--s-dark:#CB7676;--s-light:#AB5959;">var</span><span style="--s-dark:#BD976A;--s-light:#B07D48;"> promise</span><span style="--s-dark:#666666;--s-light:#999999;"> =</span><span style="--s-dark:#CB7676;--s-light:#AB5959;"> new</span><span style="--s-dark:#B8A965;--s-light:#998418;"> Promise</span><span style="--s-dark:#666666;--s-light:#999999;">(</span><span style="--s-dark:#CB7676;--s-light:#AB5959;">function</span><span style="--s-dark:#666666;--s-light:#999999;">(</span><span style="--s-dark:#BD976A;--s-light:#B07D48;">resolve</span><span style="--s-dark:#666666;--s-light:#999999;">,</span><span style="--s-dark:#BD976A;--s-light:#B07D48;">reject</span><span style="--s-dark:#666666;--s-light:#999999;">)</span><span style="--s-dark:#666666;--s-light:#999999;"> {</span></span>
<span class="line"><span style="--s-dark:#80A665;--s-light:#59873A;">    resolve</span><span style="--s-dark:#666666;--s-light:#999999;">(</span><span style="--s-dark:#C98A7D77;--s-light:#B5695977;">&#39;</span><span style="--s-dark:#C98A7D;--s-light:#B56959;">success</span><span style="--s-dark:#C98A7D77;--s-light:#B5695977;">&#39;</span><span style="--s-dark:#666666;--s-light:#999999;">);</span></span>
<span class="line"><span style="--s-dark:#666666;--s-light:#999999;">});</span></span>
<span class="line"><span style="--s-dark:#758575DD;--s-light:#A0ADA0;">// 上面的操作就已经调用了数组中的回调</span></span>
<span class="line"><span style="--s-dark:#758575DD;--s-light:#A0ADA0;">// 下面的注册的回调就会无效了</span></span>
<span class="line"><span style="--s-dark:#BD976A;--s-light:#B07D48;">promise</span><span style="--s-dark:#666666;--s-light:#999999;">.</span><span style="--s-dark:#80A665;--s-light:#59873A;">then</span><span style="--s-dark:#666666;--s-light:#999999;">(</span><span style="--s-dark:#BD976A;--s-light:#B07D48;">res</span><span style="--s-dark:#666666;--s-light:#999999;">=&gt;{</span></span>
<span class="line"><span style="--s-dark:#BD976A;--s-light:#B07D48;">    console</span><span style="--s-dark:#666666;--s-light:#999999;">.</span><span style="--s-dark:#80A665;--s-light:#59873A;">log</span><span style="--s-dark:#666666;--s-light:#999999;">(</span><span style="--s-dark:#BD976A;--s-light:#B07D48;">res</span><span style="--s-dark:#666666;--s-light:#999999;">);</span></span>
<span class="line"><span style="--s-dark:#666666;--s-light:#999999;">});</span></span></code></pre><p>我们构建了一个<code>promise</code>，直接的将这个<code>promise</code>解决掉（调用<code>resolve</code>）。</p><p><code>resolve</code>会把<code>onResolvedCallback</code>的函数逐一地执行。</p><p>注意，这时候的操作都是同步的，也就是这时的<code>then</code>注册回调还没有执行，导致了<code>then</code>方法没有被执行。</p><p>使用了<code>setTimeout</code>，使得更改状态以一个新的任务执行，也就是在当前代码执行完之后再执行，使得回调函数可以注册到<code>onResolvedCallback</code>里面。使得<code>then</code>的表现正常。</p><p>需要注意，<code>Promise</code>应该是以微任务的形式来进行<code>resolve</code>的，而不是以任务，这个在之前的关于<code>task</code>，<code>microtask</code>的文章中有说到。</p>`,21)])))}};export{_ as categories,b as date,T as default,C as key,w as meta,R as tags,P as title,x as updated,E as wordCount};
