import{createElementBlock as d,openBlock as c,createStaticVNode as t}from"vue";import{c as i}from"./app-CGnJzz9B.js";import"nprogress";import"pinia-plugin-persistedstate";import"vue-router";import"vue-router-better-scroller";import"@vueuse/core";import"@vueuse/components";import"@vueuse/router";import"octokit";import"pinia";import"date-fns";const a={class:"kan-doc"},C="HTTP强缓存和协商缓存",x=1627398288,N="2021-07-27T23:04:48.000Z",S="2023-02-13T18:28:44.000Z",L=["HTTP","缓存"],_=["笔记"],y=2127,k=[{property:"og:title",content:"HTTP强缓存和协商缓存"},{name:"twitter:title",content:"HTTP强缓存和协商缓存"}],b={__name:"HTTP强缓存和协商缓存",setup(n,{expose:o}){return o({frontmatter:{title:"HTTP强缓存和协商缓存",key:1627398288,date:"2021-07-27T23:04:48.000Z",updated:"2023-02-13T18:28:44.000Z",tags:["HTTP","缓存"],categories:["笔记"],wordCount:2127,meta:[{property:"og:title",content:"HTTP强缓存和协商缓存"},{name:"twitter:title",content:"HTTP强缓存和协商缓存"}]}}),i({title:"HTTP强缓存和协商缓存",meta:[{property:"og:title",content:"HTTP强缓存和协商缓存"},{name:"twitter:title",content:"HTTP强缓存和协商缓存"}]}),(T,e)=>(c(),d("div",a,e[0]||(e[0]=[t('<p><code>HTTP</code>强缓存和协商缓存</p><p><code>HTTP</code>中，一般把缓存分为两类，一类是强缓存，一类是协商缓存。</p><p><img src="https://z3.ax1x.com/2021/07/27/WI1DaR.png" alt=""></p><h1 id="强缓存" tabindex="-1">强缓存 <a class="header-anchor" href="#强缓存">🔗</a></h1><ul><li><code>Pragma</code>：<code>HTTP/1.0</code>定义的请求头，该请求头只有一个值，即<code>Pragma: no-cache</code>，即不使用本地缓存，强制与服务器校验缓存的有效性；</li><li><code>Cache-Control</code>：<code>HTTP/1.1</code>定义的请求头，其中<code>Cache-Control:　no-cache</code>与<code>Pragma: no-cache</code>的效果相同，不过<code>Cache-Control:　no-cache</code>不支持<code>HTTP/1.0</code>；</li><li><code>Expires</code>：<code>HTTP/1.1</code>定义的请求头，该值为一个<code>HTTP</code>日期时间戳，比如<code>Expires: Wed, 21 Oct 2021 07:28:00 GMT</code>，该头部以绝对时间来判断是否使用缓存，如果在<code>Cache-Control</code>设置了<code>max-age</code>或者<code>s-max-age</code>指令，则该请求头失效，如果使用无效的日期，则表示该资源已经过期，需要重新获取。</li></ul><p>优先级：<code>Pragma</code> -&gt; <code>Cache-Control</code> -&gt; <code>Expires</code></p><h1 id="协商缓存" tabindex="-1">协商缓存 <a class="header-anchor" href="#协商缓存">🔗</a></h1><ul><li><code>Last-Modified/If-Modified-Since/If-Unmodified-Since</code>：这三者为配套使用的请求头；以日期为单位； <ul><li><code>Last-Modified</code>：响应首部，服务器通过返回该响应头来表示资源的最后的修改日期及时间，该值为一个<code>&lt;day-name&gt;, &lt;day&gt; &lt;month&gt; &lt;year&gt; &lt;hour&gt;:&lt;minute&gt;:&lt;second&gt; GMT</code>，具体的语法可在MDN上查看<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Last-Modified" target="_blank" rel="noopener">Last-Modified - HTTP | MDN</a></li><li><code>If-Modified-Since</code>：请求条件首部，如果服务器修改了资源，那么该资源的<code>Last-Modified</code>就会改变，和客户端的<code>Last-Modified</code>就会不一致，这时<code>If-Modified-Since</code>携带的还是之前的日期，与服务器一对比发现不同，就不会返回<code>304 Not Modified</code>（表示协商缓存成功），而是重新请求完整的资源，返回<code>200 OK</code>；</li><li><code>If-Unmodified-Since</code>：请求条件首部，可以理解为和<code>If-Modified-Since</code>相似，区别在于如果服务器的资源的<code>Last-Modified</code>在<code>If-Unmodified-Since</code>之后的话，会返回<code>412 Precondition Failed</code>，只有两者想等才会返回对应的资源。</li></ul></li><li><code>ETag/If-Match/If-None-Match</code>：这两者为配套使用的请求头，以一个唯一的标签来区分资源； <ul><li><code>ETag</code>：请求响应首部，表明该资源的一个版本标识符，如果服务器上的资源没有被修改，那么两次对统一资源的请求将会返回同一个<code>ETag</code>值；<code>ETag</code>的值可以分为验证器等级以及一个唯一的标识符；</li><li><code>If-Match</code>：条件请求首部，当<code>If-Match</code>列出的标识符与服务器完全相同时，才会返回对应的资源。一般搭配<code>Range</code>头部，实现对同一文件的不同范围进行获取，如果<code>ETag</code>不匹配，返回<code>416 Range Not Satisfiable</code>；</li><li><code>If-None-Match</code>：条件请求首部，当<code>If-None-Match</code>列出的标识和服务器上没有匹配的值时，才会返回请求的资源（<code>200 OK</code>），当存在的时候，返回<code>304 Not Modified</code>（命中缓存）</li></ul></li></ul><p>优先级：<code>ETag</code> -&gt;　<code>Last-Modified</code></p><p>和缓存相关的请求头为<code>Last-Modified/If-Modified-Since</code>，<code>ETag/If-None-Match</code>。</p><p>对于<code>ETag</code>请求首部的值的生成模式，并没有规定，<code>ETag</code>的值应该符合什么规定并没有明确，但是它代表某个资源独一无二的值。对于<code>ETag</code>，有两种验证器，一种是强验证器，一种是弱验证器。</p><ul><li>强验证器（<code>Strong validation</code>）：强验证器的文件对象比较需要严格相等，及每一个字节都需要相同，在服务器层面来说比较难以保证，但是它确保了数据没有损失，同时也需要以牺牲性能为代价，该验证器的值可以使用<code>MD5</code>算法来对资源进行散列以获取唯一的值。</li><li>弱验证器（<code>Weak validation</code>）：弱验证器没有强验证器那么严格，内容相同即可认为两者是相同大的。复杂情况下可以构建一套弱验证器的体系，比如对于一个页面，即使广告内容不同，也可以认为这两个页面是相同的，那么该页面就不会重新向服务器请求。</li></ul>',12)])))}};export{_ as categories,N as date,b as default,x as key,k as meta,L as tags,C as title,S as updated,y as wordCount};
