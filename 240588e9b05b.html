<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><link rel="icon" type="image/svg+xml" href="/logo.svg"><meta name="viewport" content="width=device-width,initial-scale=1"><title>通过例子来解释防抖和节流（译）</title><script type="importmap">{"imports":{"vue":"https://esm.sh/vue","vue-router":"https://esm.sh/vue-router","pinia":"https://esm.sh/pinia","@vueuse/core":"https://esm.sh/@vueuse/core","@vueuse/components":"https://esm.sh/@vueuse/components","@vueuse/router":"https://esm.sh/@vueuse/router","date-fns":"https://esm.sh/date-fns","nprogress":"https://esm.sh/nprogress","octokit":"https://esm.sh/octokit","pinia-plugin-persistedstate":"https://esm.sh/pinia-plugin-persistedstate","vue-router-better-scroller":"https://esm.sh/vue-router-better-scroller"}}</script><script type="module" async="" crossorigin="" src="/assets/app-C4XuqRXg.js"></script><link rel="stylesheet" crossorigin="" href="/assets/app-DgCMeXmb.css"><link rel="modulepreload" crossorigin="" href="/assets/通过例子来解释防抖和节流（译）-CfKVT879.js"><meta property="og:title" content="通过例子来解释防抖和节流（译）"><meta name="twitter:title" content="通过例子来解释防抖和节流（译）"></head><body><div id="app" data-server-rendered="true"><div class="mujika" min-h="100vh" flex="~ col" bg="[--mygo-c-bg-alt]"><header class="mujika-header" flex="~ shrink-0" px-4="" h="70px" bg="[var(--mygo-c-bg)]" items-center="" justify-between="" data-v-c1947e25=""><a href="/" class="" flex="" gap-4="" items-center="" data-v-c1947e25=""><img w="40px" aspect-ratio-square="" src="/logo.svg" alt="恋の歌的logo" data-v-c1947e25=""></a><div data-v-c1947e25=""><div p-1="" flex="" gap-1="" rounded="6px" bg="[var(--mygo-c-bg-alt)]" data-v-c1947e25=""><!--[--><div leading="[1]" px-2="" py-1="" cursor-pointer="" rounded="6px" class="bg-[var(--mygo-c-bg)]" title="自动" data-v-c1947e25=""><!--[-->Auto<!--]--></div><div leading="[1]" px-2="" py-1="" cursor-pointer="" rounded="6px" class="" title="日间" data-v-c1947e25=""><!--[--><i class="i-ri:sun-line" data-v-c1947e25=""></i><!--]--></div><div leading="[1]" px-2="" py-1="" cursor-pointer="" rounded="6px" class="" title="夜间" data-v-c1947e25=""><!--[--><i class="i-ri:moon-line" data-v-c1947e25=""></i><!--]--></div><!--]--></div></div></header><main class="mujika-home" flex="grow" mx="auto" min-h="0" p-2="" w-full="" un-2xl:w="[calc(96rem-var(--spacing)*2)]"><div flex="" gap-2="" items-start=""><div flex="~ col grow" gap-2="" min-w-0=""><div class="mujika-card mujika-card--hover mujika-card--border" w-full="" overflow-auto="" data-v-7ac4adc5=""><div class="p-4 lg:p-8" data-v-7ac4adc5=""><!--[--><div flex="~ col" mb-4="" gap-4=""><h1 break-all="" text="34px center">通过例子来解释防抖和节流（译）</h1></div><div flex="~ col" gap-3="" text="[var(--mygo-c-text-2)]"><div flex="~ wrap" gap-3="" justify-center=""><!----><div flex="" gap-1="" items-center=""><i class="i-fa6-regular:calendar"></i><span un-hidden="" lg:inline="">发表于</span><span pl-1="">2023-09-12 23:49</span></div><div flex="" gap-1="" items-center=""><i class="i-fa6-regular:calendar-check"></i><span un-hidden="" lg:inline="">更新于</span><span pl-1="">2023-09-12 23:49</span></div><div flex="" gap-1="" items-center=""><i class="i-fa6-regular:folder"></i><span un-hidden="" lg:inline="">分类于</span><!--[--><a pl-1="" href="/category/译文">译文</a><!--]--></div></div><div flex="~ wrap" gap-3="" justify-center=""><div flex="" gap-1="" items-center=""><i class="i-fa6-regular:file-word"></i><span un-hidden="" lg:inline="">总字数</span><span pl-1="">3.2K</span></div><div flex="" gap-1="" items-center=""><i class="i-fa6-regular:clock"></i><span un-hidden="" lg:inline="">阅读时长 ≈</span><span pl-1="">12 分钟</span></div></div></div><div class="mujika-doc-content"><!--[--><div class="kan-doc"><h1 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言">🔗</a></h1><p>通过例子来解释防抖和节流（译）。</p><p>原文地址：<a href="https://css-tricks.com/debouncing-throttling-explained-examples/" target="_blank" rel="noopener">Debouncing and Throttling Explained Through Examples</a>。</p><p>找到这篇文章的契机是看 Lodash 文档的时候看到的，觉得不错，就写写翻译。</p><h1 id="正文" tabindex="-1">正文 <a class="header-anchor" href="#正文">🔗</a></h1><p>本文来自一位伦敦的前端工程师 <a href="https://twitter.com/dcorbacho" target="_blank" rel="noopener">David Corbacho</a> 。在<a href="https://css-tricks.com/the-difference-between-throttling-and-debouncing/" target="_blank" rel="noopener">之前</a>我们已经讨论过这个话题了，但是这次 David 会通过交互的例子来帮助你深入理解这些概念，使其变得简单清晰。</p><p><strong>Debounce</strong>（防抖）和 <strong>Throttle</strong>（节流）是两个相似的技术（其实是不同的），他们用来控制一个函数随时间的移动而允许执行的次数。</p><p>当我们对一个 DOM 事件绑定一个函数的时候，使用一个具有防抖或者节流功能版本的函数是特别有用的。为什么？因为我们在事件和函数的执行间增加了一个控制层。记住，我们不是控制抛出 DOM 事件的频率，这和前面提到的方式是各不相同的。</p><p>举个例子，比如 scroll（滚动）事件，如下：</p><iframe height="300" style="width:100%" scrolling="no" title="Scroll events counter" src="https://codepen.io/dcorb/embed/PZOZgB?default-tab=result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">See the Pen <a href="https://codepen.io/dcorb/pen/PZOZgB">Scroll events counter</a> by Corbacho (<a href="https://codepen.io/dcorb">@dcorb</a>) on <a href="https://codepen.io">CodePen</a>.</iframe><p>当通过使用触控板，滚轮或者拖动滚动条来滚动的时候，每秒会触发大约 30 次事件。但在我的测试中，在智能手机中缓慢地滚动会触发多达 100 次事件。你的滚动处理程序能很好地应对这些不同速率的滚动吗？</p><p>在 2011 年，Twitter 的 web 站点上出现了一个问题：当在 Twitter 页面内不断向下滚动时，页面会变慢，丢失响应。 John Resig 发布了一篇关于该问题的<a href="http://ejohn.org/blog/learning-from-twitter" target="_blank" rel="noopener">文章</a>，解释了直接给滚动事件绑定一个昂贵（耗时长）的函数是多么糟糕的一种方式。</p><p>John 在当时（5年前，PS：这篇文章在 2016 年发布， 5 年前也就是 2011 年）提出了一个建议的解决方案，通过在 onscroll 事件的外部启动一个 250 毫秒执行一次的定时器。这种方式下事件的处理程序不会和事件耦合。通过这种简单的技术，我们就可以避免影响用户的体验。</p><p>如今，处理事件的方式略微复杂了一些。接下来我会介绍 <strong>Debounce</strong>（防抖）、 <strong>Throttle</strong>（节流）和 <strong>requestAnimationFrame</strong> 函数，同时我们会通过相应的用例来说明。</p><h2 id="debounce（防抖）" tabindex="-1"><strong>Debounce</strong>（防抖） <a class="header-anchor" href="#debounce（防抖）">🔗</a></h2><p><strong>Debounce</strong>（防抖）技术允许我们将多个顺序调用“分组”为一个调用。</p><p><a data-fancybox="doc-gallery" href="https://i0.wp.com/css-tricks.com/wp-content/uploads/2016/04/debounce.png" target="_blank" rel="noopener noreferrer"><img src="https://i0.wp.com/css-tricks.com/wp-content/uploads/2016/04/debounce.png" alt=""></a></p><p>想象一下你现在正在电梯内，电梯门开始关闭，突然另一个人想要进来，这时电梯并不会开始楼层的移动，而是打开电梯门，现在，又突然有一个人想要进来，电梯会延后执行楼层移动的过程，虽然楼层移动的过程被延迟了，但却很好地利用了资源。</p><p>可以使用下面的例子来测试，在顶部的按钮内点击或者移动鼠标：</p><iframe height="400" style="width:100%" scrolling="no" title="Debounce. Trailing" src="https://codepen.io/dcorb/embed/KVxGqN?default-tab=result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">See the Pen <a href="https://codepen.io/dcorb/pen/KVxGqN">Debounce. Trailing</a> by Corbacho (<a href="https://codepen.io/dcorb">@dcorb</a>) on <a href="https://codepen.io">CodePen</a>.</iframe><p>你会看到一个防抖事件是如何来表示连续快速的事件的。但如果一个事件触发的间隔很大，那么防抖就不会发生。</p><h3 id="leading-前置执行（或者叫立即执行）" tabindex="-1">leading 前置执行（或者叫立即执行） <a class="header-anchor" href="#leading-前置执行（或者叫立即执行）">🔗</a></h3><p>防抖事件会在触发函数执行前进行等待，直到事件触发地不是那么快的时候再执行，这种方式可能会让你觉得恼火。为什么不立即触发函数的执行过程，这样不就和原始的，没有防抖的执行过程具有一致的行为？只是在一段快速的触发后不再执行事件。</p><p>完全没问题，这是可以实现，下面是一个有着 <code>leading</code> 标志的例子：</p><p><a data-fancybox="doc-gallery" href="https://i0.wp.com/css-tricks.com/wp-content/uploads/2016/04/debounce-leading.png" target="_blank" rel="noopener noreferrer"><img src="https://i0.wp.com/css-tricks.com/wp-content/uploads/2016/04/debounce-leading.png" alt=""></a></p><p>在 underscore 库中，该配置的参数名为 <code>immediate</code> 而不是 <code>leading</code> 。</p><p>可以自己尝试一下：</p><iframe height="400" style="width:100%" scrolling="no" title="Debounce. Leading" src="https://codepen.io/dcorb/embed/GZWqNV?default-tab=result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">See the Pen <a href="https://codepen.io/dcorb/pen/GZWqNV">Debounce. Leading</a> by Corbacho (<a href="https://codepen.io/dcorb">@dcorb</a>) on <a href="https://codepen.io">CodePen</a>.</iframe><h3 id="debounce（防抖）的实现" tabindex="-1">Debounce（防抖）的实现 <a class="header-anchor" href="#debounce（防抖）的实现">🔗</a></h3><p>我第一次看到防抖在 JavaScript 中的实现是 2009 年 John Hann 的发布的<a href="http://unscriptable.com/2009/03/20/debouncing-javascript-methods/" target="_blank" rel="noopener">帖子</a>中（这个“防抖”的术语也是他创造的）。</p><p>之后很快， Ben Alman 写了一个 JQuery 的<a href="http://benalman.com/projects/jquery-throttle-debounce-plugin/" target="_blank" rel="noopener">插件</a>（已不再维护），一年之后， Jeremy Ashkenas 把防抖加入到了 <a href="https://github.com/jashkenas/underscore/commit/9e3e067f5025dbe5e93ed784f93b233882ca0ffe" target="_blank" rel="noopener">underscore</a> 库中。后来 underscore 的替代品 Lodash 中也添加了这个实现。</p><p>这三个实现在内部有些许的不同，但他们暴露的接口几乎是完全一样的。</p><p>曾经有一段时间， underscore 采用了 Lodash 的 <code>debounce</code> 和 <code>throttle</code> 的实现。2013 年的时候我发现 <code>_.debounce</code> 函数有一个 bug 。至此，两者的实现就开始区分开了。</p><p>Lodash 为 <code>_.debounce</code> 和 <code>_.throttle</code> 添加了许多的特性。原始的 <code>immediate</code> 标志替换成了 <code>leading</code> 和 <code>trailing</code> 选项。你可以选择一个或者两个都使用。默认情况下，只会开启后置执行（trailing edge）。</p><p>新的 <code>maxWait</code> 选项（目前只有 Lodash 有这个选项）不在本文的提及范内，但是它却是非常有用的。实际上， <code>throttle</code> （节流）函数是通过使用了 <code>maxWait</code> 参数的 <code>_.debounce</code> 来定义的，你可以在 Lodash 的<a href="https://github.com/lodash/lodash/blob/4.8.0-npm/throttle.js" target="_blank" rel="noopener">源码</a>中查看它。</p><h3 id="debounce（防抖）例子" tabindex="-1"><strong>Debounce</strong>（防抖）例子 <a class="header-anchor" href="#debounce（防抖）例子">🔗</a></h3><h4 id="resize-事件的例子" tabindex="-1">resize 事件的例子 <a class="header-anchor" href="#resize-事件的例子">🔗</a></h4><p>当改变一个浏览器窗口的大小的时候，拖动窗口边缘的缩放句柄会抛出很多的 resize 事件。</p><p>可以通过下面的例子来查看：</p><iframe height="300" style="width:100%" scrolling="no" title="Debounce Resize Event Example" src="https://codepen.io/dcorb/embed/XXPjpd?default-tab=result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">See the Pen <a href="https://codepen.io/dcorb/pen/XXPjpd">Debounce Resize Event Example</a> by Corbacho (<a href="https://codepen.io/dcorb">@dcorb</a>) on <a href="https://codepen.io">CodePen</a>.</iframe><p>正如你所看到的，我们为 resize 事件使用了默认的 <code>trailing</code> 参数，因为我们只关心在用户停止缩放窗口后的最后的值。</p><h4 id="带有-ajax-请求的自动完成表单的-keypress-事件的例子" tabindex="-1">带有 Ajax 请求的自动完成表单的 keypress 事件的例子 <a class="header-anchor" href="#带有-ajax-请求的自动完成表单的-keypress-事件的例子">🔗</a></h4><p>当用户处于键盘键入的状态的时候，为什么要每隔 50ms 去发送一次 Ajax 数据呢？ <code>_.debounce</code> 可以帮我避免额外的工作，并且只在用户结束键盘键入之后去发送请求。</p><p>在下面的例子中，使用 <code>leading</code> （前置执行）标志是没有意义的。我们只是希望等待直到键入最后一个字母。</p><iframe height="300" style="width:100%" scrolling="no" title="Debouncing keystrokes Example" src="https://codepen.io/dcorb/embed/mVGVOL?default-tab=result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">See the Pen <a href="https://codepen.io/dcorb/pen/mVGVOL">Debouncing keystrokes Example</a> by Corbacho (<a href="https://codepen.io/dcorb">@dcorb</a>) on <a href="https://codepen.io">CodePen</a>.</iframe><p>还有一个相似的用例，对于验证用户的输入，我们需要等待直到用户结束键盘键入，然后去展示类似“你的密码太短”之类的消息。</p><h2 id="如何使用-debounce-和-throttle-以及常见的陷阱" tabindex="-1">如何使用 debounce 和 throttle 以及常见的陷阱 <a class="header-anchor" href="#如何使用-debounce-和-throttle-以及常见的陷阱">🔗</a></h2><p>构建你自己的或者从其他各种博客中复制的 <code>debounce</code> 和 <code>throttle</code> 函数，这种方式看起来非常吸引人。我的推荐是直接使用 underscore 库或者 Lodash 库。如果你只是需要 <code>_.debounce</code> 和 <code>_.throttle</code> 函数，你可以使用 Lodash 自定义的构建流程来输出一个自定义的压缩过后只有 2KB 的库。使用如下的简单命令来构建：</p><pre class="shiki shiki-themes vitesse-dark vitesse-light" style="--s-dark:#dbd7caee;--s-light:#393a34;--s-dark-bg:#121212;--s-light-bg:#ffffff" tabindex="0"><code class="language-bash"><span class="line"><span style="--s-dark:#80A665;--s-light:#59873A">npm</span><span style="--s-dark:#C98A7D;--s-light:#B56959"> i</span><span style="--s-dark:#C99076;--s-light:#A65E2B"> -g</span><span style="--s-dark:#C98A7D;--s-light:#B56959"> lodash-cli</span></span>
<span class="line"><span style="--s-dark:#80A665;--s-light:#59873A">lodash</span><span style="--s-dark:#C98A7D;--s-light:#B56959"> include</span><span style="--s-dark:#C98A7D;--s-light:#B56959"> =</span><span style="--s-dark:#C98A7D;--s-light:#B56959"> debounce,</span><span style="--s-dark:#C98A7D;--s-light:#B56959"> throttle</span></span></code></pre><p>即大多数时候配合 webpack ， browserify ， rollup 构建工具来使用诸如 lodash/throttle 和 lodash/debounce 或者 lodash.throttle 和 lodash.debounce 这样模块化的方式。。</p><p>调用 <code>_.debounce</code> 函数可能很容易掉入一个常见的陷阱 —— 多次调用：</p><pre class="shiki shiki-themes vitesse-dark vitesse-light" style="--s-dark:#dbd7caee;--s-light:#393a34;--s-dark-bg:#121212;--s-light-bg:#ffffff" tabindex="0"><code class="language-javascript"><span class="line"><span style="--s-dark:#758575DD;--s-light:#A0ADA0">// 错误</span></span>
<span class="line"><span style="--s-dark:#80A665;--s-light:#59873A">$</span><span style="--s-dark:#666666;--s-light:#999999">(</span><span style="--s-dark:#BD976A;--s-light:#B07D48">window</span><span style="--s-dark:#666666;--s-light:#999999">).</span><span style="--s-dark:#80A665;--s-light:#59873A">on</span><span style="--s-dark:#666666;--s-light:#999999">(</span><span style="--s-dark:#C98A7D77;--s-light:#B5695977">'</span><span style="--s-dark:#C98A7D;--s-light:#B56959">scroll</span><span style="--s-dark:#C98A7D77;--s-light:#B5695977">'</span><span style="--s-dark:#666666;--s-light:#999999">,</span><span style="--s-dark:#CB7676;--s-light:#AB5959"> function</span><span style="--s-dark:#666666;--s-light:#999999">()</span><span style="--s-dark:#666666;--s-light:#999999"> {</span></span>
<span class="line"><span style="--s-dark:#BD976A;--s-light:#B07D48">   _</span><span style="--s-dark:#666666;--s-light:#999999">.</span><span style="--s-dark:#80A665;--s-light:#59873A">debounce</span><span style="--s-dark:#666666;--s-light:#999999">(</span><span style="--s-dark:#BD976A;--s-light:#B07D48">doSomething</span><span style="--s-dark:#666666;--s-light:#999999">,</span><span style="--s-dark:#4C9A91;--s-light:#2F798A"> 300</span><span style="--s-dark:#666666;--s-light:#999999">);</span><span style="--s-dark:#DBD7CAEE;--s-light:#393A34"> </span></span>
<span class="line"><span style="--s-dark:#666666;--s-light:#999999">});</span></span>
<span class="line"></span>
<span class="line"><span style="--s-dark:#758575DD;--s-light:#A0ADA0">// 正确</span></span>
<span class="line"><span style="--s-dark:#80A665;--s-light:#59873A">$</span><span style="--s-dark:#666666;--s-light:#999999">(</span><span style="--s-dark:#BD976A;--s-light:#B07D48">window</span><span style="--s-dark:#666666;--s-light:#999999">).</span><span style="--s-dark:#80A665;--s-light:#59873A">on</span><span style="--s-dark:#666666;--s-light:#999999">(</span><span style="--s-dark:#C98A7D77;--s-light:#B5695977">'</span><span style="--s-dark:#C98A7D;--s-light:#B56959">scroll</span><span style="--s-dark:#C98A7D77;--s-light:#B5695977">'</span><span style="--s-dark:#666666;--s-light:#999999">,</span><span style="--s-dark:#BD976A;--s-light:#B07D48"> _</span><span style="--s-dark:#666666;--s-light:#999999">.</span><span style="--s-dark:#80A665;--s-light:#59873A">debounce</span><span style="--s-dark:#666666;--s-light:#999999">(</span><span style="--s-dark:#BD976A;--s-light:#B07D48">doSomething</span><span style="--s-dark:#666666;--s-light:#999999">,</span><span style="--s-dark:#4C9A91;--s-light:#2F798A"> 200</span><span style="--s-dark:#666666;--s-light:#999999">));</span></span></code></pre><p>用一个变量来存放防抖的函数可以让我们调用其 <code>cancel</code> 方法，在 Lodash 和 underscore 中都包含这个特性，如果你需要的话，可以使用它。</p><pre class="shiki shiki-themes vitesse-dark vitesse-light" style="--s-dark:#dbd7caee;--s-light:#393a34;--s-dark-bg:#121212;--s-light-bg:#ffffff" tabindex="0"><code class="language-javascript"><span class="line"><span style="--s-dark:#CB7676;--s-light:#AB5959">var</span><span style="--s-dark:#BD976A;--s-light:#B07D48"> debounced_version</span><span style="--s-dark:#666666;--s-light:#999999"> =</span><span style="--s-dark:#BD976A;--s-light:#B07D48"> _</span><span style="--s-dark:#666666;--s-light:#999999">.</span><span style="--s-dark:#80A665;--s-light:#59873A">debounce</span><span style="--s-dark:#666666;--s-light:#999999">(</span><span style="--s-dark:#BD976A;--s-light:#B07D48">doSomething</span><span style="--s-dark:#666666;--s-light:#999999">,</span><span style="--s-dark:#4C9A91;--s-light:#2F798A"> 200</span><span style="--s-dark:#666666;--s-light:#999999">);</span></span>
<span class="line"><span style="--s-dark:#80A665;--s-light:#59873A">$</span><span style="--s-dark:#666666;--s-light:#999999">(</span><span style="--s-dark:#BD976A;--s-light:#B07D48">window</span><span style="--s-dark:#666666;--s-light:#999999">).</span><span style="--s-dark:#80A665;--s-light:#59873A">on</span><span style="--s-dark:#666666;--s-light:#999999">(</span><span style="--s-dark:#C98A7D77;--s-light:#B5695977">'</span><span style="--s-dark:#C98A7D;--s-light:#B56959">scroll</span><span style="--s-dark:#C98A7D77;--s-light:#B5695977">'</span><span style="--s-dark:#666666;--s-light:#999999">,</span><span style="--s-dark:#BD976A;--s-light:#B07D48"> debounced_version</span><span style="--s-dark:#666666;--s-light:#999999">);</span></span>
<span class="line"></span>
<span class="line"><span style="--s-dark:#758575DD;--s-light:#A0ADA0">// 如果你需要这么操作</span></span>
<span class="line"><span style="--s-dark:#BD976A;--s-light:#B07D48">debounced_version</span><span style="--s-dark:#666666;--s-light:#999999">.</span><span style="--s-dark:#80A665;--s-light:#59873A">cancel</span><span style="--s-dark:#666666;--s-light:#999999">();</span></span></code></pre><h2 id="throttle（节流）" tabindex="-1">Throttle（节流） <a class="header-anchor" href="#throttle（节流）">🔗</a></h2><p>通过使用 <code>_.throttle</code> ，我们可以让函数在每 X 毫秒内只执行一次。</p><p>节流和防抖的不同之处就是节流保证函数至少在 X 毫秒内执行一次。</p><p>和防抖相同， Ben 编写的插件， underscore 库， Lodash 库也实现了这个特性。</p><h3 id="throttle（节流）例子" tabindex="-1">Throttle（节流）例子 <a class="header-anchor" href="#throttle（节流）例子">🔗</a></h3><h4 id="无限滚动例子" tabindex="-1">无限滚动例子 <a class="header-anchor" href="#无限滚动例子">🔗</a></h4><p>一个相当常见的例子。用户在可以无线滚动的页面上向下滚动。你需要检测用户到底部的距离。如果用户靠近底部了，我们应该通过 Ajax 来请求更多的内容，然后把这些内容更新到页面上。</p><p>在这里使用我们“亲爱”的 <code>_.debounce</code> 函数带来的帮助不大。它只会在用户停止滚动之后触发。而我们需要的是在用户到达底部之前就开始获取内容数据。</p><p>使用 <code>_.throttle</code> 可以保证我们时刻检测我们离底部的距离。</p><iframe height="300" style="width:100%" scrolling="no" title="Infinite scrolling throttled" src="https://codepen.io/dcorb/embed/eJLMxa?default-tab=result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">See the Pen <a href="https://codepen.io/dcorb/pen/eJLMxa">Infinite scrolling throttled</a> by Corbacho (<a href="https://codepen.io/dcorb">@dcorb</a>) on <a href="https://codepen.io">CodePen</a>.</iframe><h2 id="requestanimationframe（raf）" tabindex="-1"><strong>requestAnimationFrame</strong>（rAF） <a class="header-anchor" href="#requestanimationframe（raf）">🔗</a></h2><p><code>requestAnimationFrame</code> 是另一种限制函数执行频率的方法。</p><p>它可以当作一个 <code>_.throttle(dosomething, 16)</code> 的节流函数，但是由于它是一个浏览器的原生 API ，可用性上会更好。</p><p>考虑如下的优点或者缺点，我们可以使用 rAF 作为节流函数的一个可选替代方案。</p><h3 id="优点" tabindex="-1">优点 <a class="header-anchor" href="#优点">🔗</a></h3><ul><li>保持 60 帧（即每 16 毫秒 1 帧），但内部会以最好的时机来执行渲染。</li><li>API 相当的简单并且符合标准，在未来基本不改变，这意味着更少的维护。</li></ul><h3 id="缺点" tabindex="-1">缺点 <a class="header-anchor" href="#缺点">🔗</a></h3><ul><li>rAF 的启动和取消需要我们手动管理，不像 <code>_.debounce</code> 或者 <code>_.throttle</code> 在内部已经处理好了。</li><li>如果浏览器标签处于非活动状态， rAF 不会执行。尽管对于滚动，鼠标操作或者键盘操作来说，这并不会造成什么问题。</li><li>尽管所有的现代浏览器都提供了 rAF 函数，但 IE9 ，Opera Mini 和其他老旧的安卓浏览器仍然不支持 rAF ，你可能还是需要一个<a href="http://www.paulirish.com/2011/requestanimationframe-for-smart-animating/" target="_blank" rel="noopener">垫片</a>。</li><li>node 中并不支持 rAF 。所以你无法在服务器中通过它来节流文件系统的事件。</li></ul><p>根据我的经验，如果函数跟“绘制”或者改变属性来触发动画的话，我会使用 <code>requestAnimationFrame</code> ，即在所有涉及元素位置重计算的地方使用它。</p><p>对于发起 Ajax 请求，是否添加或者删除一个类（可能会触发一个 css 动画）的情况下，我会使用 <code>_.debounce</code> 或者 <code>_.throttle</code> ，相比 rAF ，你可以设置更低的执行频率（比如 200 毫秒，而不是 16 毫秒）。</p><p>你可能会想在 underscore 或者 Lodash 中实现 rAF ，不过这两者都拒绝了这个要求，因为这是一个专门的函数，而且很容易调用它。</p><h3 id="raf-例子" tabindex="-1">rAF 例子 <a class="header-anchor" href="#raf-例子">🔗</a></h3><p>对于 rAF ，我只介绍这一个例子，即在滚动中使用 <code>requestAnimationFrame</code> ，这里例子受到 Paul Lewis <a href="http://www.html5rocks.com/en/tutorials/speed/animations/" target="_blank" rel="noopener">文章</a>的启发，在这篇帖子中解释了该例子每一步的逻辑。</p><p>我把他和 <code>_.throttle</code> 放一起来作比较。下面的例子中可以得到相似的性能，但某些复杂的场景中 rAF 可能会得到更好的结果。</p><iframe height="300" style="width:100%" scrolling="no" title="Scroll comparison requestAnimationFrame vs throttle" src="https://codepen.io/dcorb/embed/pgOKKw?default-tab=result" frameborder="no" loading="lazy" allowtransparency="true" allowfullscreen="true">See the Pen <a href="https://codepen.io/dcorb/pen/pgOKKw">Scroll comparison requestAnimationFrame vs throttle</a> by Corbacho (<a href="https://codepen.io/dcorb">@dcorb</a>) on <a href="https://codepen.io">CodePen</a>.</iframe><p>我在 headroom.js 库中看到关于该技术的一个更高级的<a href="https://github.com/WickyNilliams/headroom.js/blob/3282c23bc69b14f21bfbaf66704fa37b58e3241d/src/Debouncer.js" target="_blank" rel="noopener">例子</a>，其中的逻辑被解耦然后封装到对象内部。</p><h2 id="结论" tabindex="-1">结论 <a class="header-anchor" href="#结论">🔗</a></h2><p>使用 <code>debounce</code> ， <code>throttle</code> 和 <code>requestAnimationFrame</code> 来优化你的事件处理程序。每个技术都有些许的不同，但他们三个都很有作用并且彼此间相辅相成。</p><p>总之：</p><ul><li><strong>debounce</strong>：将突发的事件（比如键盘点击）分组为一个事件。</li><li><strong>throttle</strong>：保证每 X 毫秒内执行一次。比如每 200 毫秒检查滚动的位置，以此来触发一个 css 动画。</li><li><strong>requestAnimationFrame</strong>：可选的 <code>throttle</code> 的一个替代。当你的函数重新计算以及重新渲染屏幕上的元素时，你需要保证平滑的变化和动画效果。请注意： IE9 下不支持该 API 。</li></ul></div><!--]--></div><div flex="~ wrap" text="[var(--mygo-c-text-2)]" mt-8="" gap-4="" justify-center=""><!--[--><div>#Debouncing</div><div>#Throttling</div><div>#JavaScript</div><!--]--></div><!--]--></div></div><div class="mujika-card mujika-card--hover mujika-card--border" w-full="" overflow-auto="" data-v-7ac4adc5=""><div class="p-4 lg:p-8" data-v-7ac4adc5=""><!--[--><div flex="~ wrap" gap-4=""><a href="/66cc63b8959c" class="" truncate="" title="Content Security policy（译）"><i class="i-mi:chevron-left" mr-1=""></i><span>Content Security policy（译）</span></a><a href="/47aa2f38ca3c" class="" ml-auto="" truncate="" title="如何分辨 getDisplayMedia 获取的是标签页、窗口或者屏幕？"><span>如何分辨 getDisplayMedia 获取的是标签页、窗口或者屏幕？</span><i class="i-mi:chevron-right" ml-1=""></i></a></div><!--]--></div></div><!--[--><div class="mujika-card mujika-card--hover mujika-card--border" w-full="" overflow-auto="" data-v-a68bfdd1="" data-v-7ac4adc5=""><div class="p-4 lg:p-8" data-v-7ac4adc5=""><!--[--><div flex="" gap-4="" items-start="" data-v-a68bfdd1=""><div flex="~ shrink-0" bg="[var(--mygo-c-bg-alt)]" rounded-6px="" w-60px="" aspect-ratio-square="" items-center="" justify-center="" data-v-a68bfdd1=""><i text-40px="" text="[#999]" class="i-fa6-regular:user" data-v-a68bfdd1=""></i></div><div flex="~ col grow" gap-2="" lg:gap-4="" data-v-a68bfdd1=""><textarea disabled="" placeholder="万水千山总是情，留下评论行不行" class="mujika-git-talk-textarea" un-disabled:cursor-not-allowed="" p-2="" outline-0="" lg:p-4="" data-v-a68bfdd1=""></textarea><div flex="" items-start="" data-v-a68bfdd1=""><a target="_blank" href="https://guides.github.com/features/mastering-markdown/" data-v-a68bfdd1="">支持 Markdown 语法</a><div ml-auto="" data-v-a68bfdd1=""></div><!----><button class="mujika-button" data-v-a68bfdd1="" data-v-15330f5f=""><!--[--><!--]--><!--[-->点击登录<!--]--></button></div></div></div><!--]--></div></div><!----><!--]--></div><aside class="mujika-aside" w="280px" flex="~ col shrink-0" top-2="" sticky="" max-h="[calc(100vh-var(--spacing)*4)]" un-hidden="" lg:block=""><div class="mujika-card mujika-card--hover mujika-card--border" w-full="" overflow-auto="" flex="~ col" gap-4="" data-v-7ac4adc5=""><!--[--><div p="4 b-0" flex-shrink-0="">文章目录</div><div p="4 t-0" flex-grow="" min-h-0="" overflow-y-auto=""><!----></div><!--]--></div></aside><!--teleport start--><!--teleport end--></div></main><footer class="mujika-footer" px-4="" py-6="" bg="[var(--mygo-c-bg)]" flex="~ col shrink-0" gap-2="" items-center="" data-v-d1d7a153=""><div flex="" items-center="" data-v-d1d7a153=""><span data-v-d1d7a153="">Power by&nbsp;</span><i class="i-logos:vue" data-v-d1d7a153=""></i><span data-v-d1d7a153="">&nbsp;+&nbsp;</span><i class="i-logos:vitejs" data-v-d1d7a153=""></i></div><div text-center="" data-v-d1d7a153=""><a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/" data-v-d1d7a153="">CC BY-NC-SA 4.0 </a>2021 - PRESENT © Dedicatus545</div><div text="[var(--mygo-c-text-2)]" text-center="" data-v-d1d7a153="">如果我和狗一样有尾巴的话，一定会藏不住这份喜悦，而尾巴一直摇个不停吧。</div></footer></div></div></body></html>